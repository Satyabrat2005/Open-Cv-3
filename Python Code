import cv2
import numpy as np
import mediapipe as mp

# Initialize MediaPipe Hands and drawing utilities
mp_hands = mp.solutions.hands
mp_drawing = mp.solutions.drawing_utils
hands = mp_hands.Hands(max_num_hands=1, min_detection_confidence=0.7)

# Colors for drawing (bright colors)
colors = [(255, 69, 0), (0, 255, 0), (0, 191, 255), (255, 215, 0), (255, 20, 147),  # Bright Red-Orange, Green, Deep Sky Blue, Gold, Deep Pink
          (255, 140, 0), (0, 255, 255), (186, 85, 211), (0, 255, 0), (255, 255, 255)]  # Bright Orange, Cyan, Medium Orchid, Lime, White

color_index = 0  # Default color is red-orange
brush_thickness = 15
eraser_mode = False  # Flag to check if the eraser is active
eraser_thickness = 20

# Brush thickness options
brush_thickness_options = [10, 15, 20, 25]
thickness_radius = 20
thickness_padding = 10

# Circle parameters
circle_radius = 30
circle_padding = 10

# Initialize OpenCV video capture
cap = cv2.VideoCapture(0)

# Variables to store previous finger position for drawing
prev_x, prev_y = None, None
drawing = False  # Flag to check if drawing should happen
buffer_points = []  # Buffer for storing points for smoothing

# Function to detect hand landmarks and return positions
def find_hand_landmarks(image, results):
    if results.multi_hand_landmarks:
        for hand_landmarks in results.multi_hand_landmarks:
            mp_drawing.draw_landmarks(image, hand_landmarks, mp_hands.HAND_CONNECTIONS)
            return hand_landmarks
    return None

# Create color selection UI (palette with circles) and brush thickness options
def draw_ui(frame, colors, selected_color_index, eraser_mode, brush_thickness_index):
    # Draw color circles in columns
    num_columns = 5
    num_rows = (len(colors) + num_columns - 1) // num_columns  # Calculate number of rows needed

    for i, color in enumerate(colors):
        col = i % num_columns  # Determine column index
        row = i // num_columns  # Determine row index
        x_center = col * (2 * circle_radius + circle_padding) + circle_radius + 10
        y_center = row * (2 * circle_radius + circle_padding) + circle_radius + 10

        # Draw the color circle
        cv2.circle(frame, (x_center, y_center), circle_radius, color, -1)

        # Highlight selected color
        if i == selected_color_index:
            cv2.circle(frame, (x_center, y_center), circle_radius + 5, (255, 255, 255), 2)

    # Add eraser button (circle) at the top right corner
    eraser_x_center = frame.shape[1] - circle_radius - 10
    eraser_y_center = circle_radius + 10
    cv2.circle(frame, (eraser_x_center, eraser_y_center), circle_radius, (50, 50, 50), -1)  # Darker gray for dark mode
    cv2.putText(frame, "Erase", (eraser_x_center - 30, eraser_y_center + 5), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)  # White text

    if eraser_mode:
        cv2.circle(frame, (eraser_x_center, eraser_y_center), circle_radius + 5, (255, 255, 255), 2)  # White outline

    # Draw brush thickness options at the bottom
    for i, thickness in enumerate(brush_thickness_options):
        x_center = i * (2 * thickness_radius + thickness_padding) + thickness_radius + 10
        y_center = frame.shape[0] - thickness_radius - 10
        color = (0, 255, 0) if thickness == brush_thickness else (100, 100, 100)  # Bright green if selected, dark gray otherwise
        cv2.circle(frame, (x_center, y_center), thickness_radius, color, -1)
        cv2.putText(frame, str(thickness), (x_center - 10, y_center + 5), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 1)  # White text

# Smooth line drawing using moving average
def draw_smooth_line(canvas, points, color, thickness):
    if len(points) > 1:
        smoothed_points = []
        for i in range(1, len(points)):
            p1 = np.array(points[i - 1])
            p2 = np.array(points[i])
            for j in range(1, 10):  # Increase the number of steps for smoother lines
                alpha = j / 10.0
                point = (1 - alpha) * p1 + alpha * p2
                smoothed_points.append(tuple(map(int, point)))
        for i in range(1, len(smoothed_points)):
            cv2.line(canvas, smoothed_points[i - 1], smoothed_points[i], color, thickness)

# Function to erase parts of the canvas
def apply_eraser(canvas, center, thickness):
    cv2.circle(canvas, center, thickness, (0, 0, 0), -1)  # Black eraser on dark mode

while True:
    ret, frame = cap.read()
    if not ret:
        break

    # Flip and convert to RGB for MediaPipe processing
    frame = cv2.flip(frame, 1)
    rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

    # Process the frame and detect hand landmarks
    result = hands.process(rgb_frame)
    hand_landmarks = find_hand_landmarks(frame, result)

    # Reduce the brightness of the frame
    frame = cv2.convertScaleAbs(frame, alpha=0.7, beta=0)  # Reduce brightness

    # Dynamically create or resize the canvas to match frame size
    if 'canvas' not in locals() or canvas.shape[:2] != frame.shape[:2]:
        canvas = np.zeros_like(frame)

    # Draw the UI (color palette, eraser, and brush thickness options) on the frame
    draw_ui(frame, colors, color_index, eraser_mode, brush_thickness)

    if hand_landmarks:
        # Get positions of landmarks
        h, w, _ = frame.shape
        index_finger_tip = hand_landmarks.landmark[mp_hands.HandLandmark.INDEX_FINGER_TIP]
        index_finger_x, index_finger_y = int(index_finger_tip.x * w), int(index_finger_tip.y * h)

        thumb_tip = hand_landmarks.landmark[mp_hands.HandLandmark.THUMB_TIP]
        thumb_x, thumb_y = int(thumb_tip.x * w), int(thumb_tip.y * h)

        middle_finger_tip = hand_landmarks.landmark[mp_hands.HandLandmark.MIDDLE_FINGER_TIP]
        middle_finger_x, middle_finger_y = int(middle_finger_tip.x * w), int(middle_finger_tip.y * h)

        # Check if the finger is hovering over the color palette
        for i in range(len(colors)):
            col = i % 5  # Determine column index
            row = i // 5  # Determine row index
            x_center = col * (2 * circle_radius + circle_padding) + circle_radius + 10
            y_center = row * (2 * circle_radius + circle_padding) + circle_radius + 10
            distance = np.sqrt((index_finger_x - x_center) ** 2 + (index_finger_y - y_center) ** 2)

            if distance < circle_radius:
                color_index = i  # Select the color
                eraser_mode = False
                cv2.putText(frame, f"Color Selected: {i}", (10, 90), cv2.FONT_HERSHEY_SIMPLEX, 1, colors[i], 2)

        # Check if the finger is hovering over the eraser (top right corner)
        eraser_x_center = frame.shape[1] - circle_radius - 10
        eraser_y_center = circle_radius + 10
        distance = np.sqrt((index_finger_x - eraser_x_center) ** 2 + (index_finger_y - eraser_y_center) ** 2)
        if distance < circle_radius:
            eraser_mode = True
            cv2.putText(frame, "Eraser Active", (10, 90), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)

        # Check if the index and middle fingers are close
        index_to_middle_distance = np.sqrt((index_finger_x - middle_finger_x) ** 2 + (index_finger_y - middle_finger_y) ** 2)
        if index_to_middle_distance < 50:  # Adjust threshold as needed
            drawing = False
            prev_x, prev_y = None, None  # Reset previous coordinates if not drawing
            buffer_points = []  # Clear the buffer points to avoid connecting lines
        else:
            # Check if only the index finger is extended
            if index_finger_tip.y < middle_finger_tip.y:
                drawing = True
            else:
                drawing = False
                prev_x, prev_y = None, None  # Reset previous coordinates if not drawing
                buffer_points = []  # Clear the buffer points to avoid connecting lines

        # Store points for smoothing
        if drawing:
            if prev_x is None and prev_y is None:
                prev_x, prev_y = index_finger_x, index_finger_y
            buffer_points.append((prev_x, prev_y))
            buffer_points.append((index_finger_x, index_finger_y))
            if len(buffer_points) > 20:  # Adjust buffer size
                buffer_points.pop(0)

            if eraser_mode:
                # Apply the eraser to the canvas
                apply_eraser(canvas, (index_finger_x, index_finger_y), eraser_thickness)
            else:
                # Draw smoothly
                draw_smooth_line(canvas, buffer_points, colors[color_index], brush_thickness)

            prev_x, prev_y = index_finger_x, index_finger_y

    else:
        prev_x, prev_y = None, None  # Reset if no hand is detected

    # Blend the canvas and the frame
    frame = cv2.addWeighted(frame, 0.7, canvas, 0.8, 0)  # Adjust blending to highlight drawing

    # Show the frame with drawings, color palette, eraser option, and brush thickness
    cv2.imshow("Hand Gesture Painter", frame)

    # Break the loop when 'q' is pressed
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release resources
cap.release()
cv2.destroyAllWindows()
